#!/usr/bin/env bash

set -e

# Parse the command line arguments
[ $# = 3 ] || { 
   echo >&2 "usage: $0 <moddir> <module> <command>" 
   exit 2
}
moddir=$1 module=$2 command=$3


# Read the stubbs function library.
STUBBS_LIB_DIR=$(dirname $(dirname $(dirname $0)))
[ ! -f "$STUBBS_LIB_DIR/functions.sh" ] && {
    echo >&2 "Could load stubbs function library: \"$STUBBS_LIB_DIR/functions.sh\""
    exit 1
}

. "$STUBBS_LIB_DIR/functions.sh" || {
   echo >&2 "Failed reading stubbs function library"
   exit 1
}

#
# _generate_option_parser_ - Generate an entry inside options.sh
#
generate_option_parser() {
	local optName=$1
    local optVarname=$(stubbs_option_variable $optName)
	local ARGUMENTS=$(stubbs_option_property $moddir/$module $optName ARGUMENTS)
	local SHORT=$(stubbs_option_property $moddir/$module $optName SHORT)
	if [ -n "${SHORT}" ] 
	then
		argstring=$(printf ' --%s|-%s' "${optName}"  "${SHORT}")
	else
		argstring=$(printf " --%s" "${optName}" )
    fi
	if [ "$ARGUMENTS" == "false" ]
	then
        # boolean flag. Check if the arg is "true" because the answers population process declares it.
		printf " %s) %s=true; [[ "\${2:-}" == "true" ]] && shift ;;\n" "${argstring}" "$optVarname"
	else
    	printf " %s) rerun_option_check \$# \$1; %s=\$2 ; shift ;;\n" \
			"$argstring" "$optVarname"
	fi
}

# list the options that set a default
options_defaulted=$(stubbs_options_matching $moddir/$module $command DEFAULT='.+')


# list the options that are required
options_required=$(stubbs_options_matching $moddir/$module $command REQUIRED=true)

# list the options that have variables to export
options_exported=$(stubbs_options_matching $moddir/$module $command EXPORT=true)

(
    cat <<EOF
# Generated by stubbs:add-option. Do not edit, if using stubbs.
# Created: $(date)
#
#/ usage: $module:$command $(stubbs_command_usage $moddir/$module $command)

# _rerun_options_parse_ - Parse the command arguments and set option variables.
#
#     rerun_options_parse "\$@"
#
# Arguments:
#
# * the command options and their arguments
#
# Notes:
# 
# * Sets shell variables for any parsed options.
# * The "-?" help argument prints command usage and will exit 2.
# * Return 0 for successful option parse.
#
rerun_options_parse() {

    while [ "\$#" -gt 0 ]; do
        OPT="\$1"
        case "\$OPT" in
$(for option in $(rerun_options $moddir $module $command); do 
printf "          %s\n" "$(generate_option_parser $option)"; 
done)
            # help option
            -|--*?)
                rerun_option_usage
                exit 2
                ;;
            # end of options, just arguments left
            *)
              break
        esac
        shift
    done

    # Set defaultable options.
$(for opt in $(echo $options_defaulted|sort); do
optvar=$(stubbs_option_variable $opt)
printf "    [ -z \"$%s\" ] && %s=\"%s\"\n" \
    $optvar $optvar \
    "\$(rerun_property_get \$RERUN_MODULE_DIR/options/$opt DEFAULT)"
done)
    # Check required options are set
$(for opt in $(echo $options_required|sort); do
printf "    [ -z \"$%s\" ] && { echo >&2 \"missing required option: --%s\" ; return 2 ; }\n" \
      $(stubbs_option_variable $opt) $opt
done)
    # If option variables are declared exportable, export them.
$(for opt in $(echo $options_exported|sort); do
printf "    export %s\n" $(stubbs_option_variable $opt)
done)
    #
    return 0
}


# If not already set, initialize the options variables to null.
$(for option in $(rerun_options $moddir $module $command); do 
printf ": \${%s:=}\n" "$(stubbs_option_variable $option)"; 
done)


EOF
) 
    # generated to stdout

