#!/usr/bin/env bash

set -e

# Parse the command line arguments
[ $# = 3 ] || {
   echo >&2 "usage: $0 <moddir> <module> <command>"
   exit 2
}
moddir=$1 module=$2 command=$3


# Read the stubbs function library.
STUBBS_LIB_DIR=$(dirname $(dirname $(dirname $0)))
[ ! -f "$STUBBS_LIB_DIR/functions.sh" ] && {
    echo >&2 "Could load stubbs function library: \"$STUBBS_LIB_DIR/functions.sh\""
    exit 1
}

. "$STUBBS_LIB_DIR/functions.sh" || {
   echo >&2 "Failed reading stubbs function library"
   exit 1
}

#
# _generate_option_parser_ - Generate an entry inside options.sh
#
generate_option_parser() {
	local optName=$1
    local optVarname=$(stubbs_option_variable $optName)
	local ARGUMENTS=$(stubbs_option_property $moddir/$module $optName ARGUMENTS)
	local SHORT=$(stubbs_option_property $moddir/$module $optName SHORT)
	if [ -n "${SHORT}" ]
	then
		argstring=$(printf ' --%s|-%s' "${optName}"  "${SHORT}")
	else
		argstring=$(printf " --%s" "${optName}" )
    fi
	if [ "$ARGUMENTS" == "false" ]
	then
        # boolean flag. Check if the arg is "true" because the answers population process declares it.
		printf " %s) %s=true; [[ "\${2:-}" == "true" ]] && shift ;;\n" "${argstring}" "$optVarname"
	else
    	printf " %s) rerun_option_check \$# \$1; %s=\$2 ; shift ;;\n" \
			"$argstring" "$optVarname"
	fi
}

#
# _generate_help_option_
#
generate_help_option() {
  cat <<-EOL
            # help option
            -|--*?) echo >&2 "unrecognized option: \$OPT"
                rerun_option_usage
                exit 2
                ;;
EOL
}

# list the options that set a default
options_defaulted=$(stubbs_options_matching $moddir/$module $command DEFAULT='.+')


# list the options that are required
options_required=$(stubbs_options_matching $moddir/$module $command REQUIRED=true)

# list the options that have variables to export
options_exported=$(stubbs_options_matching $moddir/$module $command EXPORT=true)

# get value for strict arg checking
strict_arg_checking=$(stubbs_command_property $moddir/$module $command STRICT)


(
    cat <<EOF
# Generated by stubbs:add-option. Do not edit, if using stubbs.
# Created: $(date)
#
#/ usage: $module:$command $(stubbs_command_usage $moddir/$module $command)

# _rerun_options_parse_ - Parse the command arguments and set option variables.
#
#     rerun_options_parse "\$@"
#
# Arguments:
#
# * the command options and their arguments
#
# Notes:
#
# * Sets shell variables for any parsed options.
# * The "-?" help argument prints command usage and will exit 2.
# * Return 0 for successful option parse.
#
rerun_options_parse() {

    while (( "\$#" > 0 ))
    do
        OPT="\$1"
        case "\$OPT" in
$(for option in $(rerun_options $moddir $module $command); do
printf "          %s\n" "$(generate_option_parser $option)";
done)
$(if [ "$strict_arg_checking" != "false" ]; then generate_help_option; fi)
            # end of options, just arguments left
            *)
              break
        esac
        shift
    done

    # Set defaultable options.
$(for opt in $(echo $options_defaulted|sort); do
optvar=$(stubbs_option_variable $opt)
printf "    [[ -z \"$%s\" ]] && %s=\"%s\"\n" \
    $optvar $optvar \
    "\$(rerun_property_get \$RERUN_MODULE_DIR/options/$opt DEFAULT)"
done)
    # Check required options are set
$(for opt in $(echo $options_required|sort); do
printf "    [[ -z \"$%s\" ]] && { echo >&2 \"missing required option: --%s\" ; return 2 ; }\n" \
      $(stubbs_option_variable $opt) $opt
done)
    # If option variables are declared exportable, export them.
$(for opt in $(echo $options_exported|sort); do
printf "    export %s\n" $(stubbs_option_variable $opt)
done)
    # Make remaining command line options available in $CMD_LINE
    export _CMD_LINE="\$@"
    #
    return 0
}


# If not already set, initialize the options variables to null.
$(for option in $(rerun_options $moddir $module $command); do
printf ": \${%s:=}\n" "$(stubbs_option_variable $option)";
done)
# Default command line to null if not set
: \${_CMD_LINE:=}


EOF
)
    # generated to stdout
