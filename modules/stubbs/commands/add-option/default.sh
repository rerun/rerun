#!/bin/bash
#
# NAME
#
#   add-option
#
# DESCRIPTION
#
#   add a command option
#

# Source common function library
source $RERUN_MODULES/stubbs/lib/functions.sh || { echo "failed laoding function library" ; exit 1 ; }

# Upper case the string
caps() { echo "$1" | tr '[:lower:]' '[:upper:]' ; }

# Used to generate an entry inside options.sh
add_optionparser() {
	local optName=$1
    local optNameCap=$(echo $optName | tr "[:lower:]" "[:upper:]")
	local ARGUMENTS=$(rerun_optionArguments $RERUN_MODULES $MODULE $COMMAND $optName)
	local SHORT=$(rerun_optionShort $RERUN_MODULES $MODULE $COMMAND $optName)
	if [ -n "${SHORT}" ] 
	then
		argstring=$(printf ' -%s|--%s' "${SHORT}" "${optName}")
	else
		argstring=$(printf " --%s" "${optName}" )
    fi
	if [ "$ARGUMENTS" == "false" ]
	then
		printf " %s) %s=true ;;\n" "${argstring}" "$optName" "$optNameCap"
	else
    	printf " %s) rerun_option_check \$# ; %s=\$2 ; shift ;;\n" \
			"$argstring" "$optNameCap"
	fi
}

# Init the handler
rerun_init 

# Get the options
while [ "$#" -gt 0 ]; do
    OPT="$1"
    case "$OPT" in
        # options without arguments
	# options with arguments
	-o|--name)
	    rerun_option_check "$#"
	    NAME="$2"
	    shift
	    ;;
	--desc*)
	    rerun_option_check "$#"
	    DESC="$2"
	    shift
	    ;;
	-c|--command)
	    rerun_option_check "$#"
		# Parse if command is named "module:command"
	 	regex='([^:]+)(:)([^:]+)'
		if [[ $2 =~ $regex ]]
		then
			MODULE=${BASH_REMATCH[1]}
			COMMAND=${BASH_REMATCH[3]}
		else
	    	COMMAND="$2"		
	    fi
	    shift
	    ;;
	-m|--module)
	    rerun_option_check "$#"
	    MODULE="$2"
	    shift
	    ;;
	--req*)
	    rerun_option_check "$#"
	    REQ="$2"
	    shift
	    ;;
	--arg*)
	    rerun_option_check "$#"
	    ARGS="$2"
	    shift
	    ;;
	--long)
	    rerun_option_check "$#"
	    LONG="$2"
	    shift
	    ;;
	-range)
	    rerun_option_check "$#"
	    RANGE="$2"
	    shift
	    ;;			
	--default)
	    rerun_option_check "$#"
	    DEFAULT="$2"
	    shift
	    ;;
        # unknown option
	-?)
	    rerun_option_error
	    ;;
	  # end of options, just arguments left
	*)
	    break
    esac
    shift
done

# Post process the options
[ -z "$NAME" ] && {
    echo "Name: "
    read NAME
}

[ -z "$DESC" ] && {
    echo "Description: "
    read DESC
}

[ -z "$MODULE" ] && {
    echo "Module: "
    select MODULE in $(rerun_modules $RERUN_MODULES);
    do
	echo "You picked module $MODULE ($REPLY)"
	break
    done
}

[ -z "$COMMAND" ] && {
    echo "Command: "
    select COMMAND in $(rerun_commands $RERUN_MODULES $MODULE);
    do
	echo "You picked command $COMMAND ($REPLY)"
	break
    done
}

# Verify this command exists
#
[ -d $RERUN_MODULES/$MODULE/commands/$COMMAND ] || rerun_die "command does not exist: \""$MODULE:$COMMAND\"""

# Generate metadata for new option

(
    cat <<EOF
# generated by stubbs:add-option
# $(date)
NAME=$NAME
DESCRIPTION="$DESC"
ARGUMENTS=${ARGS:-true}
REQUIRED=${REQ:-true}
SHORT=${NAME:0:1}
LONG=${LONG:-$NAME}
DEFAULT=$DEFAULT
RANGE=$RANGE

EOF
) > $RERUN_MODULES/$MODULE/commands/$COMMAND/$NAME.option || rerun_die
echo "Wrote option metadata: $RERUN_MODULES/$MODULE/commands/$COMMAND/$NAME.option"


# list the options that set a default
optionsWithDefaults=
for opt in $(rerun_options $RERUN_MODULES $MODULE $COMMAND); do
    default=$(rerun_optionDefault $RERUN_MODULES $MODULE $COMMAND $opt)
    [ -n "$default" ] && optionsWithDefaults="$optionsWithDefaults $opt"
done

# list the options that are required
optionsRequired=
for opt in $(rerun_options $RERUN_MODULES $MODULE $COMMAND); do
    required=$(rerun_optionRequired $RERUN_MODULES $MODULE $COMMAND $opt)
    [ "$required" == "true"  ] && optionsRequired="$optionsRequired $opt"
done

# Generate option parser script.

(
cat <<EOF
# generated by stubbs:add-option
# $(date)

# print USAGE and exit
rerun_option_error() {
    [ -z "\$USAGE"  ] && echo "\$USAGE" >&2
    [ -z "\$SYNTAX" ] && echo "\$SYNTAX \$*" >&2
    return 2
}

# check option has its argument
rerun_option_check() {
    [ "\$1" -lt 2 ] && rerun_option_error
}

# options: [$(rerun_options $RERUN_MODULES $MODULE $COMMAND)]
while [ "\$#" -gt 0 ]; do
    OPT="\$1"
    case "\$OPT" in
        $(for o in $(rerun_options $RERUN_MODULES $MODULE $COMMAND); do printf "%8s\n" "$(add_optionparser $o)"; done)
        # unknown option
        -?)
            rerun_option_error
            ;;
        # end of options, just arguments left
        *)
          break
    esac
    shift
done

# If defaultable options variables are unset, set them to their DEFAULT
$(for opt in $(echo $optionsWithDefaults|sort); do
printf "[ -z \"$%s\" ] && %s=%s\n" $(caps $opt) $(caps $opt) $(rerun_optionDefault $RERUN_MODULES $MODULE $COMMAND $opt)
done)
# Check required options are set
$(for opt in $(echo $optionsRequired|sort); do
printf "[ -z \"$%s\" ] && { echo \"missing required option: --%s\" ; return 2 ; }\n" $(caps $opt) $opt
done)
#
return 0
EOF
) > $RERUN_MODULES/$MODULE/commands/$COMMAND/options.sh || rerun_die
echo "Wrote options script: $RERUN_MODULES/$MODULE/commands/$COMMAND/options.sh"

# Done


